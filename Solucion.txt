class Prenda {
  var tipoPrenda;
  var categoria;
  var material;
  var trama;
  var colorPrincipal;
  var colorSecundario;
  var temperaturaMaxima
  
    constructor(tipoPrenda,material,colorPrincipal,trama,categoria,temperaturaMaxima){
      
      this.tipoPrenda = tipoPrenda;
      this.material = material;
      this.colorPrincipal = colorPrincipal;
      this.trama = trama;
      this.categoria = categoria;
      this.temperaturaMaxima = temperaturaMaxima;
    }
    
    method setColorSecundario(color){
      colorSecundario = color;
    }

    method esValida(){
    Validador.queNoSeaNulo(tipoPrenda,"Falta Tipo");
    Validador.queNoSeaNulo(categoria, "Falta Categoria");
    Validador.queNoSeaNulo(material, "Falta Material");
    Validador.queNoSeaNulo(colorPrincipal, "Falta Color Principal");
    Validador.categoriaCondiceConTipo(categoria, tipoPrenda, "No se condice la categoria con su tipo");
    }
}

enum Categoria {
  PARTE_SUPERIOR, PARTE_INFERIOR, CALZADO, ACCESORIOS
}

enum Material {
  PIQUE, ALGODON, LANA //puede haber abstraccion material que incluya tmb la trama y/o color
}

enum Trama {
  LISA, RAYADA, CON_LUNARES, A_CUADROS, ESTAMPADA
}

class Tipo {
  var nombreTipo;
  var categoria;
  
  method getCategoria(){
    return categoria;
  }
}

class Color {
  var rojo;
  var verde;
  var azul;
}

class Validador{
  
  method queNoSeaNulo(objeto,exepcion){
    if(!objecto){
      throw new Exeption(exepcion);
    }
  }
  
  method categoriaCondiceConTipo(categoria,tipo,exepcion){
    if(categoria != tipo.categoriaPrenda){
      throw new Exeption(exepcion);
    }
    
  }
}

class Atuendo {
  var prendas = [];
}

//Agrego clase para tener estados intermedios de la prenda, especie de builder, como desventaja es el acoplamiento
//y el tener que repetir los atributos de prenda dentro de borrador (a veces repetir validaciones)

class Borrador {
  var tipoPrenda;
  var categoria;
  var material;
  var colorPrincipal;
  var colorSecundario;
  var trama = Trama.LISA; //requerimiento en que si no indico nada queda la trama LISA
  var temperaturaMaxima;

    method construirPrenda() {
      prenda = new Prenda(tipoPrenda,material,colorPrincipal,trama,categoria,temperaturaMaxima);

      prenda.esValida();

      if (colorSecundario != NULL){
      prenda.setColorSecundario(colorSecundario);
    }

      return prenda;
  }

    method setTipoPrenda(tipo){ //Se pueden agregar validaciones en cada set o especificar
      this.tipoPrenda = tipo;
  }

    method setCategoria(categoria){
      this.categoria = categoria;
  }

    method setMaterial(material){
      this.material = material;
  }

    method setColorPrincipal(colorP){
      this.colorPrincipal = colorP;
  }

    method setColorSegundario(colorS){
      this.colorSecundario = colorS;
  }

    method setTrama(trama){
      this.trama = trama;
  }

}

//Clase uniforme que seria un estilo de la de prenda.

class Uniforme {
  var parteSuperior;
  var parteInferior;
  var calzado;

  constructor(parteSuperior,parteInferior,calzado){

    this.parteSuperior = parteSuperior;
    this.parteInferior = parteInferior;
    this.calzado = calzado;
  }
}

abstract class CreadorUniformes {

  method armarUniforme(){
    new Uniforme(this.crearParteSuperior(), this.crearParteInferior, this.crearCalzado)
  }

  abstract method crearParteSuperior();  //cada uno de estos es un Factory Method
  abstract method crearParteInferior();
  abstract method crearCalzado();
}

class colegioSanJuan inherits CreadorUniformes {

  method crearParteSuperior(){
    borrador = new Borrador(CHOMBA);
    borrador.setColorPrincipal(new Color(//aca numeros rgb de color verde));
    borrador.setMaterial(PIQUE);
    borrador.setCategoria(PARTE_SUPERIOR);
    return borrador.construirPrenda();
  }

  method crearParteInferior(){
    borrador = new Borrador(PANTALON);
    borrador.setColorPrincipal(new Color(//aca numeros rgb de gris));
    borrador.setMaterial(ACETATO);
    borrador.setCategoria(PARTE_INFERIOR);
    return borrador.construirPrenda();
  }

  method crearCalzado(){
    borrador = new Borrador(ZAPATILLAS);
    borrador.setColorPrincipal(new Color(//aca numeros rgb color blanco));
    borrador.setCategoria(CALZADO);
    return borrador.construirPrenda();
  }
}

//Seria algo parecido al colegio san juan

class colegioJohnson inherits CreadorUniformes {

  method crearParteSuperior(){

  }

  method crearParteInferior(){

  }

  method crearCalzado(){
    
  }
}


ACLARACIONES: (primera iteracion)
Decido hacer un constructor en el que se validan que no sean nulos los atributos que si o si tienen que estar.
Agrego una validacion tambien para el ultimo requerimiento (nose si esta bien planteado), me fijo que sean iguales
tanto la categoria en la prenda, como la categoria en el tipo de la prenda.
Para el caso del color secundario que es opcional lo agrego mediante un setter. (se puede sobrecargar el constructor).


ACLARACIONES: (segunda iteracion)
Decido hacer una clase borrador como piden en el requermiento que se puede ir completando a medida que nosotros
queramos, y llamamos a construir cuando ya decidamos que sea la prenda final. Las validaciones las dejo en el
constructor de la prenda. De esta forma solo podremos de vuelta construir una prenda siempre y cuando se valida.
Para el caso de los uniformes hice un intento de lo que creo que es el patron Factory Method. Creo la clase abstracta
y de ella heredan las que saben como armar cada uniforme de cada institucion.
Queda pendiente el diagrama de clases ya que tengo dudas de como hacerlo teniendo en cuenta que quise implementar un 
factory method mas la clase borrador.


ACLARACIONES: (cuarta iteracion)
